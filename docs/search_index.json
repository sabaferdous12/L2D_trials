[["index.html", "Learning Python Chapter 1 About Python 1.1 What's Python? 1.2 Scientific Programming 1.3 Bibliography", " Learning Python Saba Ferdous 2022-01-07 Chapter 1 About Python \"Python has gotten sufficiently weapons grade that we don’t descend into R anymore. Sorry, R people. I used to be one of you but we no longer descend into R.\" – Chris Wiggins 1.1 What's Python? Python is a general-purpose programming language conceived in 1989 by Dutch programmer Guido van Rossum. Python is free and open source, with development coordinated through the Python Software Foundation. Python has experienced rapid adoption in the last decade and is now one of the most commonly used programming languages. Popular textbooks on Python programming include {cite}guttag2016introduction and {cite}hill2016learning. 1.1.1 Common Uses Python is a general-purpose language used in almost all application domains such as communications web development CGI and graphical user interfaces game development multimedia, data processing, security, etc., etc., etc. Python is beginner-friendly and routinely used to teach computer science and programming in top computer science programs. Python is particularly popular within the scientific and data science communities. It is steadily replacing familiar tools like Excel in the fields of finance and banking. 1.1.2 Relative Popularity The following chart, produced using Stack Overflow Trends, shows one measure of the relative popularity of Python {figure} /_static/lecture_specific/about_py/python_vs_matlab.png :scale: 72% The figure indicates not only that Python is widely used but also that adoption of Python has accelerated significantly since 2012. This is driven at least in part by uptake in the scientific domain, particularly in rapidly growing fields like data science. For example, the popularity of pandas, a library for data analysis with Python has exploded, as seen here. (The corresponding time path for MATLAB is shown for comparison) {figure} /_static/lecture_specific/about_py/pandas_vs_matlab.png :scale: 23% Note that pandas takes off in 2012, which is the same year that we see Python's popularity begin to spike in the first figure. Overall, it's clear that Python is one of the most popular programming languages worldwide. Python is a major tool for scientific computing, accounting for a rapidly rising share of scientific work around the globe. 1.1.3 Features Python is a high-level language suitable for rapid development. It has a relatively small core language supported by many libraries. Multiple programming styles are supported (procedural, object-oriented, functional, etc.) Python is interpreted rather than compiled. 1.1.4 Syntax and Design One nice feature of Python is its elegant syntax — we'll see many examples later on. Elegant code might sound superfluous but in fact it's highly beneficial because it makes the syntax easy to read and easy to remember. Remembering how to read from files, sort dictionaries and other such routine tasks means that you don't need to break your flow in order to hunt down correct syntax. Closely related to elegant syntax is an elegant design. Features like iterators, generators, decorators and list comprehensions make Python highly expressive, allowing you to get more done with less code. Namespaces improve productivity by cutting down on bugs and syntax errors. 1.2 Scientific Programming Python has become one of the core languages of scientific computing. It's either the dominant player or a major player in machine learning and data science astronomy artificial intelligence chemistry computational biology meteorology Its popularity in economics is also beginning to rise. 1.3 Bibliography {bibliography} ../_bibliography/references.bib (getting_started)= "],["setting-up-your-python-environment.html", "Chapter 2 Setting up Your Python Environment 2.1 Overview 2.2 Anaconda 2.3 Jupyter Notebooks", " Chapter 2 Setting up Your Python Environment 2.1 Overview In this lecture, you will learn how to get a Python environment up and running execute simple Python commands run a sample program install the code libraries that underpin these lectures 2.2 Anaconda The core Python package is easy to install but not what you should choose for these lectures. These lectures require the entire scientific programming ecosystem, which the core installation doesn't provide is painful to install one piece at a time. Hence the best approach for our purposes is to install a Python distribution that contains the core Python language and compatible versions of the most popular scientific libraries. The best such distribution is Anaconda. Anaconda is very popular cross-platform comprehensive completely unrelated to the Nicki Minaj song of the same name Anaconda also comes with a great package management system to organize your code libraries. All of what follows assumes that you adopt this recommendation! (install_anaconda)= 2.2.1 Installing Anaconda To install Anaconda, download the binary and follow the instructions. Important points: Install the latest version! If you are asked during the installation process whether you'd like to make Anaconda your default Python installation, say yes. 2.2.2 Updating Anaconda Anaconda supplies a tool called conda to manage and upgrade your Anaconda packages. One conda command you should execute regularly is the one that updates the whole Anaconda distribution. As a practice run, please execute the following Open up a terminal Type conda update anaconda For more information on conda, type conda help in a terminal. (ipython_notebook)= 2.3 Jupyter Notebooks Jupyter notebooks are one of the many possible ways to interact with Python and the scientific libraries. They use a browser-based interface to Python with The ability to write and execute Python commands. Formatted output in the browser, including tables, figures, animation, etc. The option to mix in formatted text and mathematical expressions. Because of these features, Jupyter is now a major player in the scientific computing ecosystem. {numref}Figure %s &lt;jp_demo&gt; shows the execution of some code (borrowed from here) in a Jupyter notebook ```{figure} /_static/lecture_specific/getting_started/jp_demo.png :scale: 50% :name: jp_demo A Jupyter notebook viewed in the browser While Jupyter isn\\&#39;t the only way to code in Python, it\\&#39;s great for when you wish to - get started - test new ideas or interact with small pieces of code - share scientific ideas with students or colleagues ### Starting the Jupyter Notebook Once you have installed Anaconda, you can start the Jupyter notebook. Either - search for Jupyter in your applications menu, or - open up a terminal and type `jupyter notebook` - Windows users should substitute \\&quot;Anaconda command prompt\\&quot; for \\&quot;terminal\\&quot; in the previous line. If you use the second option, you will see something like this ```{figure} /_static/lecture_specific/getting_started/starting_nb.png :scale: 50% The output tells us the notebook is running at http://localhost:8888/ localhost is the name of the local machine 8888 refers to port number 8888 on your computer Thus, the Jupyter kernel is listening for Python commands on port 8888 of our local machine. Hopefully, your default browser has also opened up with a web page that looks something like this {figure} /_static/lecture_specific/getting_started/nb.png :scale: 50% What you see here is called the Jupyter dashboard. If you look at the URL at the top, it should be localhost:8888 or similar, matching the message above. Assuming all this has worked OK, you can now click on New at the top right and select Python 3 or similar. Here's what shows up on our machine: {figure} /_static/lecture_specific/getting_started/nb2.png :scale: 50% The notebook displays an active cell, into which you can type Python commands. 2.3.1 Notebook Basics Let's start with how to edit code and run simple programs. 2.3.1.1 Running Cells Notice that, in the previous figure, the cell is surrounded by a green border. This means that the cell is in edit mode. In this mode, whatever you type will appear in the cell with the flashing cursor. When you're ready to execute the code in a cell, hit Shift-Enter instead of the usual Enter. {figure} /_static/lecture_specific/getting_started/nb3.png :scale: 50% (Note: There are also menu and button options for running code in a cell that you can find by exploring) 2.3.1.2 Modal Editing The next thing to understand about the Jupyter notebook is that it uses a modal editing system. This means that the effect of typing at the keyboard depends on which mode you are in. The two modes are Edit mode Indicated by a green border around one cell, plus a blinking cursor Whatever you type appears as is in that cell Command mode The green border is replaced by a grey (or grey and blue) border Keystrokes are interpreted as commands — for example, typing b adds a new cell below the current one To switch to - command mode from edit mode, hit the Esc key or Ctrl-M - edit mode from command mode, hit Enter or click in a cell The modal behavior of the Jupyter notebook is very efficient when you get used to it. 2.3.1.3 Inserting Unicode (e.g., Greek Letters) Python supports unicode, allowing the use of characters such as \\(\\alpha\\) and \\(\\beta\\) as names in your code. In a code cell, try typing \\alpha and then hitting the tab key on your keyboard. (a_test_program)= 2.3.1.4 A Test Program Let's run a test program. Here's an arbitrary program we can use: http://matplotlib.org/3.1.1/gallery/pie_and_polar_charts/polar_bar.html. On that page, you'll see the following code ```{code-cell} ipython3 import numpy as np import matplotlib.pyplot as plt %matplotlib inline "],["fixing-random-state-for-reproducibility.html", "Chapter 3 Fixing random state for reproducibility", " Chapter 3 Fixing random state for reproducibility np.random.seed(19680801) "],["compute-pie-slices.html", "Chapter 4 Compute pie slices", " Chapter 4 Compute pie slices N = 20 Î¸ = np.linspace(0.0, 2 * np.pi, N, endpoint=False) radii = 10 * np.random.rand(N) width = np.pi / 4 * np.random.rand(N) colors = plt.cm.viridis(radii / 10.) ax = plt.subplot(111, projection=‘polar’) ax.bar(Î¸, radii, width=width, bottom=0.0, color=colors, alpha=0.5) plt.show() Don\\&#39;t worry about the details for now --- let\\&#39;s just run it and see what happens. The easiest way to run this code is to copy and paste it into a cell in the notebook. Hopefully you will get a similar plot. ### Working with the Notebook Here are a few more tips on working with Jupyter notebooks. #### Tab Completion In the previous program, we executed the line `import numpy as np` - NumPy is a numerical library we\\&#39;ll work with in depth. After this import command, functions in NumPy can be accessed with `np.function_name` type syntax. - For example, try `np.random.randn(3)`. We can explore these attributes of `np` using the `Tab` key. For example, here we type `np.ran` and hit Tab ```{figure} /_static/lecture_specific/getting_started/nb6.png :scale: 50% Jupyter offers up the two possible completions, random and rank. In this way, the Tab key helps remind you of what's available and also saves you typing. (gs_help)= 4.0.0.1 On-Line Help To get help on np.rank, say, we can execute np.rank?. Documentation appears in a split window of the browser, like so {figure} /_static/lecture_specific/getting_started/nb6a.png :scale: 50% Clicking on the top right of the lower split closes the on-line help. 4.0.0.2 Other Content In addition to executing code, the Jupyter notebook allows you to embed text, equations, figures and even videos in the page. For example, here we enter a mixture of plain text and LaTeX instead of code {figure} /_static/lecture_specific/getting_started/nb7.png :scale: 50% Next we Esc to enter command mode and then type m to indicate that we are writing Markdown, a mark-up language similar to (but simpler than) LaTeX. (You can also use your mouse to select Markdown from the Code drop-down box just below the list of menu items) Now we Shift+Enter to produce this {figure} /_static/lecture_specific/getting_started/nb8.png :scale: 50% 4.0.1 Sharing Notebooks Notebook files are just text files structured in JSON and typically ending with .ipynb. You can share them in the usual way that you share files — or by using web services such as nbviewer. The notebooks you see on that site are static html representations. To run one, download it as an ipynb file by clicking on the download icon. Save it somewhere, navigate to it from the Jupyter dashboard and then run as discussed above. (python_by_example)= "],["an-introductory-example.html", "Chapter 5 An Introductory Example 5.1 Overview 5.2 The Task: Plotting a White Noise Process 5.3 Version 1 5.4 Alternative Implementations 5.5 Another Application 5.6 Exercises 5.7 Solutions", " Chapter 5 An Introductory Example 5.1 Overview We're now ready to start learning the Python language itself. In this lecture, we will write and then pick apart small Python programs. The objective is to introduce you to basic Python syntax and data structures. Deeper concepts will be covered in later lectures. You should have read the {ref}lecture &lt;getting_started&gt; on getting started with Python before beginning this one. 5.2 The Task: Plotting a White Noise Process Suppose we want to simulate and plot the white noise process \\(\\epsilon_0, \\epsilon_1, \\ldots, \\epsilon_T\\), where each draw \\(\\epsilon_t\\) is independent standard normal. In other words, we want to generate figures that look something like this: {figure} /_static/lecture_specific/python_by_example/test_program_1_updated.png (Here \\(t\\) is on the horizontal axis and \\(\\epsilon_t\\) is on the vertical axis.) We'll do this in several different ways, each time learning something more about Python. We run the following command first, which helps ensure that plots appear in the notebook if you run it on your own machine. %matplotlib inline 5.3 Version 1 (ourfirstprog)= Here are a few lines of code that perform the task we set import numpy as np import matplotlib.pyplot as plt iµ_values = np.random.randn(100) plt.plot(Ïµ_values) plt.show() Let's break this program down and see how it works. (import)= 5.3.1 Imports The first two lines of the program import functionality from external code libraries. The first line imports NumPy, a favorite Python package for tasks like working with arrays (vectors and matrices) common mathematical functions like cos and sqrt generating random numbers linear algebra, etc. After import numpy as np we have access to these attributes via the syntax np.attribute. Here's two more examples np.sqrt(4) np.log(4) We could also use the following syntax: import numpy numpy.sqrt(4) But the former method (using the short name np) is convenient and more standard. 5.3.1.1 Why So Many Imports? Python programs typically require several import statements. The reason is that the core language is deliberately kept small, so that it's easy to learn and maintain. When you want to do something interesting with Python, you almost always need to import additional functionality. 5.3.1.2 Packages As stated above, NumPy is a Python package. Packages are used by developers to organize code they wish to share. In fact, a package is just a directory containing files with Python code — called modules in Python speak possibly some compiled code that can be accessed by Python (e.g., functions compiled from C or FORTRAN code) a file called __init__.py that specifies what will be executed when we type import package_name In fact, you can find and explore the directory for NumPy on your computer easily enough if you look around. On this machine, it's located in anaconda3/lib/python3.7/site-packages/numpy 5.3.1.3 Subpackages Consider the line Ïµ_values = np.random.randn(100). Here np refers to the package NumPy, while random is a subpackage of NumPy. Subpackages are just packages that are subdirectories of another package. 5.3.2 Importing Names Directly Recall this code that we saw above import numpy as np np.sqrt(4) Here's another way to access NumPy's square root function from numpy import sqrt sqrt(4) This is also fine. The advantage is less typing if we use sqrt often in our code. The disadvantage is that, in a long program, these two lines might be separated by many other lines. Then it's harder for readers to know where sqrt came from, should they wish to. 5.3.3 Random Draws Returning to our program that plots white noise, the remaining three lines after the import statements are iµ_values = np.random.randn(100) plt.plot(Ïµ_values) plt.show() The first line generates 100 (quasi) independent standard normals and stores them in Ïµ_values. The next two lines genererate the plot. We can and will look at various ways to configure and improve this plot below. 5.4 Alternative Implementations Let's try writing some alternative versions of {ref}our first program &lt;ourfirstprog&gt;, which plotted IID draws from the normal distribution. The programs below are less efficient than the original one, and hence somewhat artificial. But they do help us illustrate some important Python syntax and semantics in a familiar setting. 5.4.1 A Version with a For Loop Here's a version that illustrates for loops and Python lists. (firstloopprog)= ts_length = 100 Ïµ_values = [] # empty list for i in range(ts_length): e = np.random.randn() Ïµ_values.append(e) plt.plot(Ïµ_values) plt.show() In brief, The first line sets the desired length of the time series. The next line creates an empty list called Ïµ_values that will store the \\(\\epsilon_t\\) values as we generate them. The statement # empty list is a comment, and is ignored by Python's interpreter. The next three lines are the for loop, which repeatedly draws a new random number \\(\\epsilon_t\\) and appends it to the end of the list Ïµ_values. The last two lines generate the plot and display it to the user. Let's study some parts of this program in more detail. (lists_ref)= 5.4.2 Lists Consider the statement Ïµ_values = [], which creates an empty list. Lists are a native Python data structure used to group a collection of objects. For example, try x = [10, &#39;foo&#39;, False] type(x) The first element of x is an integer, the next is a string, and the third is a Boolean value. When adding a value to a list, we can use the syntax list_name.append(some_value) x x.append(2.5) x Here append() is what's called a method, which is a function \"attached to\" an object—in this case, the list x. We'll learn all about methods later on, but just to give you some idea, Python objects such as lists, strings, etc. all have methods that are used to manipulate the data contained in the object. String objects have string methods, list objects have list methods, etc. Another useful list method is pop() x x.pop() x Lists in Python are zero-based (as in C, Java or Go), so the first element is referenced by x[0] x[0] # first element of x x[1] # second element of x 5.4.3 The For Loop Now let's consider the for loop from {ref}the program above &lt;firstloopprog&gt;, which was for i in range(ts_length): e = np.random.randn() Ïµ_values.append(e) Python executes the two indented lines ts_length times before moving on. These two lines are called a code block, since they comprise the \"block\" of code that we are looping over. Unlike most other languages, Python knows the extent of the code block only from indentation. In our program, indentation decreases after line Ïµ_values.append(e), telling Python that this line marks the lower limit of the code block. More on indentation below—for now, let's look at another example of a for loop animals = [&#39;dog&#39;, &#39;cat&#39;, &#39;bird&#39;] for animal in animals: print(&quot;The plural of &quot; + animal + &quot; is &quot; + animal + &quot;s&quot;) This example helps to clarify how the for loop works: When we execute a loop of the form --- class: no-execute --- for variable_name in sequence: &lt;code block&gt; The Python interpreter performs the following: For each element of the sequence, it \"binds\" the name variable_name to that element and then executes the code block. The sequence object can in fact be a very general object, as we'll see soon enough. 5.4.4 A Comment on Indentation In discussing the for loop, we explained that the code blocks being looped over are delimited by indentation. In fact, in Python, all code blocks (i.e., those occurring inside loops, if clauses, function definitions, etc.) are delimited by indentation. Thus, unlike most other languages, whitespace in Python code affects the output of the program. Once you get used to it, this is a good thing: It forces clean, consistent indentation, improving readability removes clutter, such as the brackets or end statements used in other languages On the other hand, it takes a bit of care to get right, so please remember: The line before the start of a code block always ends in a colon for i in range(10): if x &gt; y: while x &lt; 100: etc., etc. All lines in a code block must have the same amount of indentation. The Python standard is 4 spaces, and that's what you should use. 5.4.5 While Loops The for loop is the most common technique for iteration in Python. But, for the purpose of illustration, let's modify {ref}the program above &lt;firstloopprog&gt; to use a while loop instead. (whileloopprog)= ts_length = 100 Ïµ_values = [] i = 0 while i &lt; ts_length: e = np.random.randn() Ïµ_values.append(e) i = i + 1 plt.plot(Ïµ_values) plt.show() Note that the code block for the while loop is again delimited only by indentation the statement i = i + 1 can be replaced by i += 1 5.5 Another Application Let's do one more application before we turn to exercises. In this application, we plot the balance of a bank account over time. There are no withdraws over the time period, the last date of which is denoted by \\(T\\). The initial balance is \\(b_0\\) and the interest rate is \\(r\\). The balance updates from period \\(t\\) to \\(t+1\\) according to :label: ilom b_{t+1} = (1 + r) b_t In the code below, we generate and plot the sequence \\(b_0, b_1, \\ldots, b_T\\) generated by {eq}ilom. Instead of using a Python list to store this sequence, we will use a NumPy array. r = 0.025 # interest rate T = 50 # end date b = np.empty(T+1) # an empty NumPy array, to store all b_t b[0] = 10 # initial balance for t in range(T): b[t+1] = (1 + r) * b[t] plt.plot(b, label=&#39;bank balance&#39;) plt.legend() plt.show() The statement b = np.empty(T+1) allocates storage in memory for T+1 (floating point) numbers. These numbers are filled in by the for loop. Allocating memory at the start is more efficient than using a Python list and append, since the latter must repeatedly ask for storage space from the operating system. Notice that we added a legend to the plot — a feature you will be asked to use in the exercises. 5.6 Exercises Now we turn to exercises. It is important that you complete them before continuing, since they present new concepts we will need. 5.6.1 Exercise 1 Your first task is to simulate and plot the correlated time series \\[ x_{t+1} = \\alpha \\, x_t + \\epsilon_{t+1} \\quad \\text{where} \\quad x_0 = 0 \\quad \\text{and} \\quad t = 0,\\ldots,T \\] The sequence of shocks \\(\\{\\epsilon_t\\}\\) is assumed to be IID and standard normal. In your solution, restrict your import statements to import numpy as np import matplotlib.pyplot as plt Set \\(T=200\\) and \\(\\alpha = 0.9\\). 5.6.2 Exercise 2 Starting with your solution to exercise 2, plot three simulated time series, one for each of the cases \\(\\alpha=0\\), \\(\\alpha=0.8\\) and \\(\\alpha=0.98\\). Use a for loop to step through the \\(\\alpha\\) values. If you can, add a legend, to help distinguish between the three time series. Hints: If you call the plot() function multiple times before calling show(), all of the lines you produce will end up on the same figure. For the legend, noted that the expression 'foo' + str(42) evaluates to 'foo42'. 5.6.3 Exercise 3 Similar to the previous exercises, plot the time series \\[ x_{t+1} = \\alpha \\, |x_t| + \\epsilon_{t+1} \\quad \\text{where} \\quad x_0 = 0 \\quad \\text{and} \\quad t = 0,\\ldots,T \\] Use \\(T=200\\), \\(\\alpha = 0.9\\) and \\(\\{\\epsilon_t\\}\\) as before. Search online for a function that can be used to compute the absolute value \\(|x_t|\\). 5.6.4 Exercise 4 One important aspect of essentially all programming languages is branching and conditions. In Python, conditions are usually implemented with if–else syntax. Here's an example, that prints -1 for each negative number in an array and 1 for each nonnegative number numbers = [-9, 2.3, -11, 0] for x in numbers: if x &lt; 0: print(-1) else: print(1) Now, write a new solution to Exercise 3 that does not use an existing function to compute the absolute value. Replace this existing function with an if–else condition. (pbe_ex3)= 5.6.5 Exercise 5 Here's a harder exercise, that takes some thought and planning. The task is to compute an approximation to \\(\\pi\\) using Monte Carlo. Use no imports besides import numpy as np Your hints are as follows: If \\(U\\) is a bivariate uniform random variable on the unit square \\((0, 1)^2\\), then the probability that \\(U\\) lies in a subset \\(B\\) of \\((0,1)^2\\) is equal to the area of \\(B\\). If \\(U_1,\\ldots,U_n\\) are IID copies of \\(U\\), then, as \\(n\\) gets large, the fraction that falls in \\(B\\), converges to the probability of landing in \\(B\\). For a circle, \\(area = \\pi * radius^2\\). 5.7 Solutions 5.7.1 Exercise 1 Here's one solution. Î± = 0.9 T = 200 x = np.empty(T+1) x[0] = 0 for t in range(T): x[t+1] = Î± * x[t] + np.random.randn() plt.plot(x) plt.show() 5.7.2 Exercise 2 Î±_values = [0.0, 0.8, 0.98] T = 200 x = np.empty(T+1) for Î± in Î±_values: x[0] = 0 for t in range(T): x[t+1] = Î± * x[t] + np.random.randn() plt.plot(x, label=f&#39;$\\\\alpha = {Î±}$&#39;) plt.legend() plt.show() 5.7.3 Exercise 3 Here's one solution: Î± = 0.9 T = 200 x = np.empty(T+1) x[0] = 0 for t in range(T): x[t+1] = Î± * np.abs(x[t]) + np.random.randn() plt.plot(x) plt.show() 5.7.4 Exercise 4 Here's one way: Î± = 0.9 T = 200 x = np.empty(T+1) x[0] = 0 for t in range(T): if x[t] &lt; 0: abs_x = - x[t] else: abs_x = x[t] x[t+1] = Î± * abs_x + np.random.randn() plt.plot(x) plt.show() Here's a shorter way to write the same thing: Î± = 0.9 T = 200 x = np.empty(T+1) x[0] = 0 for t in range(T): abs_x = - x[t] if x[t] &lt; 0 else x[t] x[t+1] = Î± * abs_x + np.random.randn() plt.plot(x) plt.show() 5.7.5 Exercise 5 Consider the circle of diameter 1 embedded in the unit square. Let \\(A\\) be its area and let \\(r=1/2\\) be its radius. If we know \\(\\pi\\) then we can compute \\(A\\) via \\(A = \\pi r^2\\). But here the point is to compute \\(\\pi\\), which we can do by \\(\\pi = A / r^2\\). Summary: If we can estimate the area of a circle with diameter 1, then dividing by \\(r^2 = (1/2)^2 = 1/4\\) gives an estimate of \\(\\pi\\). We estimate the area by sampling bivariate uniforms and looking at the fraction that falls into the circle. n = 100000 count = 0 for i in range(n): u, v = np.random.uniform(), np.random.uniform() d = np.sqrt((u - 0.5)**2 + (v - 0.5)**2) if d &lt; 0.5: count += 1 area_estimate = count / n print(area_estimate * 4) # dividing by radius**2 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
